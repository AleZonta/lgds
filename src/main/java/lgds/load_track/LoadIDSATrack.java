package lgds.load_track;

import lgds.POI.POI;
import lgds.config.ConfigFile;
import lgds.trajectories.Point;
import lgds.trajectories.Trajectories;
import lgds.trajectories.Trajectory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * Created by alessandrozonta on 28/10/2016.
 * This class will load the traces from a file
 * The traces are generated by IDSA simulator and saved into a file
 */
public class LoadIDSATrack implements Traces {
    private String source; //location of the gps data
    private Double max_length; //max length trajectory
    private Boolean translation; // do i have to translate the coordinates

    /**
     * Load position trajectories reading the path from file
     */
    public LoadIDSATrack(){
        // load config file
        ConfigFile conf = new ConfigFile();
        try {
            conf.loadFile();
            this.source = conf.getIDSATraces();

            Double length = conf.getMaxLength();
            //if length is set to 999999.0 it means no limit
            if(length == 999999.0){
                this.max_length = Double.MAX_VALUE;
            }else{
                this.max_length = length;
            }

            this.translation = conf.getTranslate();
        } catch (Exception e){
            this.source = null;
            this.translation = Boolean.FALSE;
            this.max_length = Double.MAX_VALUE;
        }

    }

    /**
     * Scan the folder (location read from a file) and load in memory all the trajectories
     * This method is specific for the IDSA simulator's traces
     * Every person has a line containing all his trajectory
     * It calculates the root of the word and its height and width
     *
     * @return trajectories -> class containing all the trajectories loaded
     */
    public Trajectories loadTrajectories(){
        Trajectories trajectories = new Trajectories();
        //initialise to zero the value for the root and height and width
        Point minValue = new Point(Double.MAX_VALUE,Double.MAX_VALUE);
        Point maxValue = new Point(Double.MIN_VALUE,Double.MIN_VALUE);

        Point root = new Point(588636.0471215437, 5763563.815469695);

        final Integer[] count = {0};

        List<Double> tt = new ArrayList<>();
        //read file into stream, try-with-resources
        //count the total trajectory read
        final Integer[] totalTrajectories = {0};
        try (Stream<String> stream = Files.lines(Paths.get(this.source))) {

            stream.forEach(array -> {
                if(!Objects.equals(array, "")){
                    List<String> splittedList = Arrays.asList(array.split(";"));

                    //I am going to transform the string into the correct values
                    Trajectory trajectory = new Trajectory();
                    //set full loaded to true
                    trajectory.setFullLoad(Boolean.TRUE);
                    //set first point
                    List<String> firstElement = Arrays.asList(splittedList.get(0).split(","));
                    if (this.translation){
                        trajectory.setFirstPoint(this.convertFromUTMtoDeg(new Point(Double.parseDouble(firstElement.get(0)),Double.parseDouble(firstElement.get(1))), root));
                    }else{
                        trajectory.setFirstPoint(new Point(Double.parseDouble(firstElement.get(0)),Double.parseDouble(firstElement.get(1))));
                    }

                    //Remove the first trajectory
                    splittedList = splittedList.subList(1, splittedList.size());
                    splittedList.stream().forEach(el -> {
                        if(!Objects.equals(el, " ")) {
                            List<String> elements = Arrays.asList(el.split(","));
                            try {
                                if (this.translation){
                                    trajectory.addPoint(this.convertFromUTMtoDeg(new Point(Double.parseDouble(elements.get(0)), Double.parseDouble(elements.get(1))), root));
                                }else{
                                    trajectory.addPoint(new Point(Double.parseDouble(elements.get(0)), Double.parseDouble(elements.get(1))));
                                }
                            } catch (Exception e) {
                                String a = "";
                            }
                        }
                    });

                    //set last point
                    List<String> lastElement = Arrays.asList(splittedList.get(splittedList.size() - 2).split(","));
//                    trajectory.setLastPoint(new Point(Double.parseDouble(lastElement.get(0)),Double.parseDouble(lastElement.get(1))));
                    Point lastPoint;
                    if (this.translation){
                        lastPoint = this.convertFromUTMtoDeg(new Point(Double.parseDouble(lastElement.get(0)),Double.parseDouble(lastElement.get(1))), root);
                    }else{
                        lastPoint = new Point(Double.parseDouble(lastElement.get(0)),Double.parseDouble(lastElement.get(1)));
                    }
                    trajectory.setLastPoint(lastPoint);
                    //always add the end point to the list that contains all the POIs
                    trajectories.addPOItoTotalList(new POI(lastPoint));
                    //set path
                    trajectory.setPath(this.source + "//" + count[0].toString());
                    //set number of points
                    trajectory.setSize(splittedList.size());
                    count[0]++;

                    //determine geo bounding box
                    splittedList.stream().forEach(s -> {
                        if (!Objects.equals(s, " ")) {
                            List<String> el = Arrays.asList(s.split(","));
                            Point point;
                            if (this.translation){
                                point = this.convertFromUTMtoDeg(new Point(Double.parseDouble(el.get(0)),Double.parseDouble(el.get(1))), root);
                            }else {
                                point = new Point(Double.parseDouble(el.get(0)), Double.parseDouble(el.get(1)));
                            }
                            Double lat = point.getLatitude();
                            Double lon = point.getLongitude();
                            minValue.setLatitude(Math.min(minValue.getLatitude(), lat));
                            minValue.setLongitude(Math.min(minValue.getLongitude(), lon));
                            maxValue.setLatitude(Math.max(maxValue.getLatitude(), lat));
                            maxValue.setLongitude(Math.max(maxValue.getLongitude(), lon));
                        }
                    });

                    //determine distance between points
                    List<String> el = Arrays.asList(splittedList.get(0).split(","));
                    Point p = this.convertFromUTMtoDeg(new Point(Double.parseDouble(el.get(0)), Double.parseDouble(el.get(1))), new Point(588636.0471215437, 5763563.815469695));
                    Double latSource = p.getLatitude();
                    Double lonSource = p.getLongitude();
                    Double total = 0d;
                    for(int z = 1; z < splittedList.size(); z++){
                        if(!Objects.equals(splittedList.get(z), " ")) {
                            List<String> elDestination = Arrays.asList(splittedList.get(z).split(","));
                            Point pp = this.convertFromUTMtoDeg(new Point(Double.parseDouble(elDestination.get(0)), Double.parseDouble(elDestination.get(1))), new Point(588636.0471215437, 5763563.815469695));
                            Double latDestination = pp.getLatitude();
                            Double lonDestination = pp.getLongitude();
                            total += trajectories.retDistanceUsingDistanceClass(new double[]{latSource, lonSource}, new double[]{latDestination, lonDestination});
                            latSource = latDestination;
                            lonSource = lonDestination;
                        }
                    }
//                    System.out.println(total);
                    tt.add(total);
                    totalTrajectories[0]++;
                    //discriminate length trajectory
                    //only if shorter than max_length i will add the trajectory
                    if(total < this.max_length) {
                        //I also want a lowerbound for number of step -> I found example with 5 steps (I do not like them)
                        //hardcoded minimum number of steps -> 30?
                        //if(list.size() > 30) {
                        trajectories.addTrajectory(trajectory);
                    }
                }

            });

        } catch (IOException e) {
            e.printStackTrace();
        }


//        Double max = tt.stream().max(Double::compare).get();
//        Double min = tt.stream().min(Double::compare).get();
//        System.out.println("Max is -> " + max + " and Min is -> " + min);
//        Long c = tt.stream().filter(el -> el > 2000000.0).count();
//        Long d = tt.stream().filter(el -> el > 1000000.0).count();
//        Long e = tt.stream().filter(el -> el > 800000.0).count();
//        Long f = tt.stream().filter(el -> el > 160000.0).count();
//        System.out.println(">2M -> " + c);
//        System.out.println(">1M -> " + d);
//        System.out.println(">800K -> " + e);
//        System.out.println(">160K -> " + f);
//        System.out.println("Tot -> " + tt.size());

        // With this coordinate this is not the root.
        //I need to find it on IDSA and hard code it here
        trajectories.setRootAndWhWorld(root, new Point(maxValue.getLatitude() - minValue.getLatitude(), maxValue.getLongitude() - minValue.getLongitude()));
        System.out.println("Max length selected is " + this.max_length);
        System.out.println("From " + totalTrajectories[0] + " to " + trajectories.getTrajectories().size() + " trajectories loaded");
        return trajectories;
    }

    /**
     * Load a specific line of the trajectory from the file
     * @param path path of the file containing all the point of the trajectory
     * @param position position that we have already reached
     * @return the new point read from file
     */
    public Point loadTrajectory(String path, Integer position){
        return null;
    }


    /**
     * Convert from UTM point to Normal coordinate
     * IDSA is using UTM coordinate to represent everything
     * code found http://stackoverflow.com/questions/176137/java-convert-lat-lon-to-utm
     * @param oldpoint UTM point
     * @param root root point of the map
     * @return Normal Coordinate Point
     */
    public Point convertFromUTMtoDeg(Point oldpoint, Point root){
        Integer zone = 31; // Netherlands area code
        double easting = root.getLatitude() + oldpoint.getLatitude();
        double north = root.getLongitude() + oldpoint.getLongitude();
        double latitude = (north/6366197.724/0.9996+(1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)-0.006739496742*Math.sin(north/6366197.724/0.9996)*Math.cos(north/6366197.724/0.9996)*(Math.atan(Math.cos(Math.atan(( Math.exp((easting - 500000) / (0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting - 500000) / (0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2)/3))-Math.exp(-(easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*( 1 -  0.006739496742*Math.pow((easting - 500000) / (0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2)/3)))/2/Math.cos((north-0.9996*6399593.625*(north/6366197.724/0.9996-0.006739496742*3/4*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.pow(0.006739496742*3/4,2)*5/3*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996 )/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4-Math.pow(0.006739496742*3/4,3)*35/27*(5*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/3))/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2))+north/6366197.724/0.9996)))*Math.tan((north-0.9996*6399593.625*(north/6366197.724/0.9996 - 0.006739496742*3/4*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.pow(0.006739496742*3/4,2)*5/3*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996 )*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4-Math.pow(0.006739496742*3/4,3)*35/27*(5*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/3))/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2))+north/6366197.724/0.9996))-north/6366197.724/0.9996)*3/2)*(Math.atan(Math.cos(Math.atan((Math.exp((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2)/3))-Math.exp(-(easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2)/3)))/2/Math.cos((north-0.9996*6399593.625*(north/6366197.724/0.9996-0.006739496742*3/4*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.pow(0.006739496742*3/4,2)*5/3*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4-Math.pow(0.006739496742*3/4,3)*35/27*(5*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/3))/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2))+north/6366197.724/0.9996)))*Math.tan((north-0.9996*6399593.625*(north/6366197.724/0.9996-0.006739496742*3/4*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.pow(0.006739496742*3/4,2)*5/3*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4-Math.pow(0.006739496742*3/4,3)*35/27*(5*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/3))/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2))+north/6366197.724/0.9996))-north/6366197.724/0.9996))*180/Math.PI;
        latitude = Math.round(latitude * 10000000);
        latitude = latitude/10000000;
        double longitude = Math.atan((Math.exp((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2)/3))-Math.exp(-(easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2)/3)))/2/Math.cos((north-0.9996*6399593.625*( north/6366197.724/0.9996-0.006739496742*3/4*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.pow(0.006739496742*3/4,2)*5/3*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2* north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4-Math.pow(0.006739496742*3/4,3)*35/27*(5*(3*(north/6366197.724/0.9996+Math.sin(2*north/6366197.724/0.9996)/2)+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/4+Math.sin(2*north/6366197.724/0.9996)*Math.pow(Math.cos(north/6366197.724/0.9996),2)*Math.pow(Math.cos(north/6366197.724/0.9996),2))/3)) / (0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2))))*(1-0.006739496742*Math.pow((easting-500000)/(0.9996*6399593.625/Math.sqrt((1+0.006739496742*Math.pow(Math.cos(north/6366197.724/0.9996),2)))),2)/2*Math.pow(Math.cos(north/6366197.724/0.9996),2))+north/6366197.724/0.9996))*180/Math.PI+zone*6-183;
        longitude = Math.round(longitude*10000000);
        longitude = longitude/10000000;
        return new Point(latitude, longitude);
    }

}
