package lgds.load_track;

import lgds.trajectories.Point;
import lgds.trajectories.Trajectories;
import lgds.trajectories.Trajectory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * Created by alessandrozonta on 28/10/2016.
 * This class will load the traces from a file
 * The traces are generated by IDSA simulator and saved into a file
 */
public class LoadIDSATrack implements Traces {
    private String source; //location of the gps data

    /**
     * Load position trajectories reading the path from file
     */
    public LoadIDSATrack(){
        String path = Paths.get(".").toAbsolutePath().normalize().toString() + "/source.conf";
        try {
            BufferedReader brTest = new BufferedReader(new FileReader(path));
            this.source = brTest.readLine();
        } catch (IOException e) {
            this.source = null;
        }
    }

    /**
     * Scan the folder (location read from a file) and load in memory all the trajectories
     * This method is specific for the IDSA simulator's traces
     * Every person has a line containing all his trajectory
     * It calculates the root of the word and its height and width
     *
     * @return trajectories -> class containing all the trajectories loaded
     */
    public Trajectories loadTrajectories(){
        Trajectories trajectories = new Trajectories();
        //load the file
        File sourceFile = new File(this.source);
        //initialise to zero the value for the root and height and width
        Point minValue = new Point(Double.MAX_VALUE,Double.MAX_VALUE);
        Point maxValue = new Point(Double.MIN_VALUE,Double.MIN_VALUE);


        final Integer[] count = {0};
        //read file into stream, try-with-resources
        try (Stream<String> stream = Files.lines(Paths.get(this.source))) {

            stream.forEach(array -> {
                if(!Objects.equals(array, "")){
                    List<String> splittedList = Arrays.asList(array.split(";"));

                    //I am going to transform the string into the correct values
                    Trajectory trajectory = new Trajectory();
                    //set first point
                    List<String> firstElement = Arrays.asList(splittedList.get(0).split(","));
                    trajectory.setFirstPoint(new Point(Double.parseDouble(firstElement.get(0)),Double.parseDouble(firstElement.get(1))));

                    //set last point
                    List<String> lastElement = Arrays.asList(splittedList.get(splittedList.size() - 2).split(","));
                    trajectory.setLastPoint(new Point(Double.parseDouble(lastElement.get(0)),Double.parseDouble(lastElement.get(1))));
                    //set path
                    trajectory.setPath(this.source + "//" + count[0].toString());
                    //set number of points
                    trajectory.setSize(splittedList.size());
                    count[0]++;

                    //determine geo bounding box
                    splittedList.stream().forEach(s -> {
                        if (!Objects.equals(s, " ")) {
                            List<String> el = Arrays.asList(s.split(","));
                            Double lat = Double.parseDouble(el.get(0));
                            Double lon = Double.parseDouble(el.get(1));
                            minValue.setLatitude(Math.min(minValue.getLatitude(), lat));
                            minValue.setLongitude(Math.min(minValue.getLongitude(), lon));
                            maxValue.setLatitude(Math.max(maxValue.getLatitude(), lat));
                            maxValue.setLongitude(Math.max(maxValue.getLongitude(), lon));
                        }
                    });

                    trajectories.addTrajectory(trajectory);
                }

            });

        } catch (IOException e) {
            e.printStackTrace();
        }
        trajectories.setRootAndWhWorld(new Point(minValue.getLatitude(), minValue.getLongitude()), new Point(maxValue.getLatitude() - minValue.getLatitude(), maxValue.getLongitude() - minValue.getLongitude()));
        return trajectories;
    }

    /**
     * Load a specific line of the trajectory from the file
     * @param path path of the file containing all the point of the trajectory
     * @param position position that we have already reached
     * @return the new point read from file
     */
    public Point loadTrajectory(String path, Integer position){
        return null;
    }

}
